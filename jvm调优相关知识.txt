jvm调优知识
数据类型：基本类型和引用类型   （基本类型一般运用在栈）
基本类型： byte,short,init,long,char,float,double,Boolean
应用类型：	类的类型（对象），接口类型和数组
栈是运行是的单位。而堆是存储的单位 （栈和线程绑定，通过追踪对象的指针绑定）
栈其实也可以用来存储数据
栈中存储指令（基本类型和引用）
栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类 型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。 

堆中存储数据（对象，对象包含了编写的数据结构，编写的处理数据逻辑）

程序运行只在栈中执行，没有指针的概念，只存在传递基本类型和对象引用问题，不会直接传对象本身

垃圾回收方式
1 标记清除 （内存使用率不高） mark-sweep
第一阶段引用根节点开始标记所有被引用的对象。第二阶段遍历整个堆，把为标记的对象清除。
缺点： 会暂停应用，产生碎片

2  复制 （适合新生代）
把内存空间划分为2个区域，每次使用一个区域，垃圾回收是，遍历使用的区域，
把正在使用的对象复制到另一个区域中，此算法每次只处理正在使用的对象，复制成本较小
复制同时还会进行相应的内存整理，不会出现碎片
缺点： 需要双倍的空间

3 标记整理 mark-compact
结合标记清除和复制2个算法的优点，第一阶段从根节点开始标记所有被引用的对象
第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块。按顺序排放
优点：没有碎片，表面内存空间消耗

按系统线程分垃圾回收

串行收集： 使用单线程处理所有垃圾回收工作，无需多线程交互，实现容易
而且效率比较高，但是局限性也明显，无法使用多处理器。
缺点： 适合单处理器，无法充分利用cpu

并行收集： 使用多线程处理垃圾回收工作，因而速度快，效率高，理论上cpu
数目越多，越能体现出并行收集的优势

并发收集： 前面2个在进行垃圾回收工作时，需要暂停整个运行环境，而只有
垃圾回收程序在运行，因此在垃圾回收是有明显的暂停，而且暂停时间会因为堆
越大而时间越长


年轻代，年老代，持久代
年轻代		（尽可能回收垃圾对象）
分为三个区eden1个  surbibor2个（一般而言）
大部分对象在eden区中生产，当eden区满时，还存活的对象将被复制到so区其中的一个
，当so区满时，此区的存活被复制到另一个so区，当这个so区满时，从一个so区复制
过来的并且还存活的对象，将被复制到老年区中，注意so两个区没有先后关系，是
对称的，所以同一个区中可能同时存在从eden复制过来的对象，和从前一个so区复制过来的
对象，而复制到老年区的只有从第一个人so区过来的底线，而且so区总有一个是空的，
根据程序需要，so区可以配置多个（多于两个），还可以增加年轻代中存在的时间，
减少被放到老年代的问题。
年老代 
生命周期较长的
持久代
用于存放静态文件，如java类，方法等。持久代对垃圾回收没有显著影响，但是有
些应用可能生成动态或者调用一些class，例如hibernate等，在这时候需要设置一
个比较大的持久代空间来存放这些运行过程中的类，通过-XX:MaxPermSize=<N>设置

gc类型，触发gc条件
scavenge gc
新对象生成，在eden申请空间失败，会触发sc gc，对eden区域进行gc，清楚非存活对象
并且把存活的转移到so区，然后整理so2个区，这种方式是对年轻代的eden区进行gc
eden区不会分配的很大，所eden的gc会频繁进行，需要使用速度快，效率高的算法
不会影响老年代
full gc 
对整个堆进行整理，包括young tenured和per，因为需要对整个堆进行回收，比scgc慢
所以要尽量减少
年老代被写满
持久代被写满
scgc被显示调用
上一次gc之后的heap的各域变化

常见jvm设置参数
堆设置
-Xms: 初始堆大小 （最大4个g）
-Xmx: 最大堆大小  （最大4个g） 一般这是和初始相等
-XX:NewSize=n 设置年轻代大小
-XX:NewRaito=n 设置年轻代和老年代的比值。如为3，则表示年轻代与老年代比值为1:3，占4分之一
-XX:SurbiborRatio=n 年轻代中eden区与两个so区比值，如3，表示eden:so=3:2，一个so区占1/5
-XX:MaxPermSize=n 设置持久代大小
收集器设置
-XX:+UseSerialGC 设置串行收集器
-XX:+UseParallelGC 设置并行收集器
-XX:+UseParalledlOldGC 设置并行老年代收集器 
-XX:+UseConcMarkSweepGc 设置并发收集器
垃圾回收统计信息
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:filename
并行收集器设置
-XX:ParalleGCThreads=n 设置并行收集时使用的CPU数，并行收集线程数
-XX:MaxGCPauseMillis=n 设置并行收集最大暂停时间
-XX:GCTimeRation=n		设置垃圾回收时间与程序运行时间的百分比。公司为1/(1+n）

















